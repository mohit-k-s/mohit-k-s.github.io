<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>V8_internals on Mohit&#39;s Page</title>
    <link>https://mohit-k-s.github.io/tags/v8_internals/</link>
    <description>Recent content in V8_internals on Mohit&#39;s Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <copyright>Mohit Kumar</copyright>
    <lastBuildDate>Sun, 10 Aug 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://mohit-k-s.github.io/tags/v8_internals/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>169220804: Yet Another Magic Number</title>
      <link>https://mohit-k-s.github.io/blog/2025/js/arrays/</link>
      <pubDate>Sun, 10 Aug 2025 00:00:00 +0000</pubDate>
      <guid>https://mohit-k-s.github.io/blog/2025/js/arrays/</guid>
      <description>&lt;p&gt;I was poking around with Node.js arrays, trying to see how far I could push them&#xA;Here’s the simple code I ran:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;at&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1e9&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;at&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This is just a standard array, and of course it fails — there’s no way my system has ~7.5 GB available just for this process.&#xA;But it fails with an interesting error:&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-log&#34; data-lang=&#34;log&#34;&gt;#&#xA;# Fatal error in , line 0&#xA;# Fatal JavaScript invalid size error 169220804 (see crbug.com/1201626)&#xA;#&#xA;#&#xA;#&#xA;#FailureMessage Object: 0x16bc59878&#xA;----- Native stack trace -----&#xA;&#xA; 1: 0x104301560 node::NodePlatform::GetStackTracePrinter()::$_0::__invoke() [/Users/mohit/.nvm/versions/node/v20.19.0/bin/node]&#xA;  ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What’s that number &lt;em&gt;169220804&lt;/em&gt;?&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>I was poking around with Node.js arrays, trying to see how far I could push them
Here’s the simple code I ran:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kr">const</span> <span class="nx">at</span> <span class="o">=</span> <span class="p">[]</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span><span class="mi">0</span> <span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mf">1e9</span> <span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">at</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is just a standard array, and of course it fails — there’s no way my system has ~7.5 GB available just for this process.
But it fails with an interesting error:</p>





<pre tabindex="0"><code class="language-log" data-lang="log">#
# Fatal error in , line 0
# Fatal JavaScript invalid size error 169220804 (see crbug.com/1201626)
#
#
#
#FailureMessage Object: 0x16bc59878
----- Native stack trace -----

 1: 0x104301560 node::NodePlatform::GetStackTracePrinter()::$_0::__invoke() [/Users/mohit/.nvm/versions/node/v20.19.0/bin/node]
  ...</code></pre><p>What’s that number <em>169220804</em>?</p>
<p>You might think: “Maybe if I just create an array of length <em>169220803</em>, it’ll work?” Nope !</p>
<p>Each node version ships with a particular v8, here is my config</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">➜ node -p process.versions
</span></span><span class="line"><span class="cl"><span class="o">{</span>
</span></span><span class="line"><span class="cl">  node: <span class="s1">&#39;20.19.0&#39;</span>,
</span></span><span class="line"><span class="cl">  v8: <span class="s1">&#39;11.3.244.8-node.26&#39;</span>,
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl"><span class="o">}</span></span></span></code></pre></div><p>So, I checked that branch of the V8 source.
kMaxSize is defined <a href="https://chromium.googlesource.com/v8/v8/&#43;/refs/heads/11.3.244/src/objects/fixed-array.h#91">here</a>.</p>
<p>That’s the max size in bytes, but the max number of elements comes from <a href="https://chromium.googlesource.com/v8/v8/&#43;/refs/heads/11.3.244/src/objects/fixed-array.h#207">kMaxLength</a> which works out to <em>134,217,728</em> elements.</p>
<p>So in theory, creating an array of that length is fine.
But my program is using .push().</p>
<h2 id="the-growth-rule">The growth rule</h2>
<p>When .push() needs more capacity, V8 allocates a new backing store at ~1.5× the old size and copies the elements over.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl">  <span class="c1">// file src/builtins/growable-fixed-array-gen.cc
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// Growth rate is analog to JSObject::NewElementsCapacity:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// new_capacity = (current_capacity + (current_capacity &gt;&gt; 1)) + 16.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="n">TNode</span><span class="o">&lt;</span><span class="n">IntPtrT</span><span class="o">&gt;</span> <span class="n">new_capacity</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl">      <span class="n">IntPtrAdd</span><span class="p">(</span><span class="n">IntPtrAdd</span><span class="p">(</span><span class="n">current_capacity</span><span class="p">,</span> <span class="n">WordShr</span><span class="p">(</span><span class="n">current_capacity</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
</span></span><span class="line"><span class="cl">                <span class="n">IntPtrConstant</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span></span></span></code></pre></div><h2 id="finding-the-actual-limit">Finding the actual limit</h2>
<p>At first , I didn&rsquo;t know the above formula and just wanted to find the point at which i start seeing these errors so , I wrote a quick binary search to find the exact point where the above error appears.</p>
<p>The magic number turned out to be <em>112,813,859</em> elements.</p>
<p>If we plug that into the growth formula:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">new_capacity</span> <span class="o">=</span> <span class="mi">112_813_859</span> <span class="o">+</span> <span class="nx">floor</span><span class="p">(</span><span class="mi">112_813_859</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl">             <span class="o">=</span> <span class="mi">112_813_859</span> <span class="o">+</span> <span class="mi">56_406_929</span> <span class="o">+</span> <span class="mi">16</span>
</span></span><span class="line"><span class="cl">             <span class="o">=</span> <span class="mi">169_220_804</span></span></span></code></pre></div><p>Ahh, that exact same number.
It all makes sense now. <br>
I tried running this in later node versions , the program always breaks at that limit.</p>
<h2 id="takeaways">Takeaways</h2>
<ol>
<li>
<p>While the theoritical limit is way higher for array length, their maximum size and growth behavior are constrained by V8’s internal constants like <code>kMaxSize</code> and <code>kMaxLength</code>.</p>
</li>
<li>
<p>Understanding these engine-level limits is essential when working with extremely large arrays or developing performance-critical applications that rely on dynamic array growth.</p>
</li>
<li>
<p>For predictable and efficient handling of large numeric datasets, consider using typed arrays (<code>Uint8Array</code>, <code>Float64Array</code>, etc.), which have fixed size and avoid the overhead and limits of dynamic arrays.</p>
</li>
</ol>
]]></content:encoded>
    </item>
  </channel>
</rss>
